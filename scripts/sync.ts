
import { createClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';
import fs from 'fs';
import matter from 'gray-matter';
import path from 'path';
import { fileURLToPath } from 'url';

// Load environment variables
dotenv.config();

const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!SUPABASE_URL || !SUPABASE_KEY) {
  console.error('Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY');
  process.exit(1);
}

const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const PROJECT_ROOT = path.resolve(__dirname, '..');
const CONTENT_DIR = path.join(PROJECT_ROOT, 'content');

// --- Types ---

interface FrontMatter {
  slug: string; // Required, Global Unique
  title: string; // Required
  excerpt?: string;
  tags?: string[];
  published_date?: string | null;
  [key: string]: any;
}

interface PostRow {
  id?: string; // Generated by DB (or selected back)
  slug: string;
  title: string;
  excerpt: string;
  content_md: string;
  category: string;
  published_date: string | null;
}

interface TagRow {
  id?: string;
  name: string;
  slug: string;
}

interface NodeItem {
  type: 'folder' | 'post';
  path: string; // Full relative path from content/ e.g. "projects/app/foo.md"
  slug: string; // node_slug (filename for post, dirname for folder)
  title: string;
  category: string;
  parentPath: string | null; // "projects/app" or null for roots
  postId?: string; // For verification later
  postSlug?: string; // For linking to post
}

// --- Helpers ---

// Safe Slugify with Unicode support and Fallback
function slugify(text: string): string {
  const input = text.toString();
  const normalized = input.normalize('NFKC').trim().toLowerCase();
  
  const slug = normalized
    .replace(/\s+/g, '-')             // Replace spaces with -
    .replace(/[^\p{L}\p{N}_\-]+/gu, '') // Allow letters, numbers, _, - (Unicode aware)
    .replace(/\-\-+/g, '-')           // Replace multiple - with single -
    .replace(/^-+/, '')               // Trim - from start
    .replace(/-+$/, '');              // Trim - from end

  if (!slug) {
     // Fallback: tag-{hash} (deterministic)
     let hash = 0;
     for (let i = 0; i < input.length; i++) {
        hash = ((hash << 5) - hash) + input.charCodeAt(i);
        hash |= 0; // Convert to 32bit integer
     }
     return `tag-${Math.abs(hash)}`;
  }
  return slug;
}

// Normalize Date to YYYY-MM-DD or null
function normalizePublishedDate(input: any): string | null {
  if (!input) return null;
  
  if (input instanceof Date) {
    // 3) UTCãšã‚Œé˜²æ­¢ã®ãŸã‚ create methods ã‚’ä½¿ç”¨
    const y = input.getFullYear();
    const m = (input.getMonth() + 1).toString().padStart(2, '0');
    const d = input.getDate().toString().padStart(2, '0');
    return `${y}-${m}-${d}`;
  }
  
  if (typeof input === 'string') {
     // Extract YYYY-MM-DD or YYYY/MM/DD at start
     const match = input.match(/^\d{4}[-/]\d{2}[-/]\d{2}/);
     if (match) {
        return match[0].replace(/\//g, '-');
     }
  }
  
  return null; // Invalid format -> null
}

// --- Main Logic ---

async function main() {
  console.log('ðŸš€ Starting Sync...');

  if (!fs.existsSync(CONTENT_DIR)) {
    console.error(`Content directory not found at: ${CONTENT_DIR}`);
    process.exit(1);
  }

  // 1. Scan and Parse Files
  const files: string[] = [];
  function scanDir(dir: string) {
    const items = fs.readdirSync(dir);
    for (const item of items) {
      const fullPath = path.join(dir, item);
      const stat = fs.statSync(fullPath);
      if (stat.isDirectory()) {
        scanDir(fullPath);
      } else if (item.endsWith('.md')) {
        files.push(fullPath);
      }
    }
  }
  scanDir(CONTENT_DIR);
  console.log(`Found ${files.length} markdown files.`);

  // Data Containers
  const posts: PostRow[] = []; // Accumulate posts
  const tagsMap = new Map<string, { slug: string; name: string }>(); // slug -> {slug, name} (First wins)
  const filePostMap = new Map<string, string>(); // relativeFilePath -> postSlug
  
  // Note Node Tree Construction Data
  const nodes: NodeItem[] = [];
  const ROOT_CATEGORIES = ['projects', 'certifications', 'notes'];
  
  // Helper to get relative path
  const getRelPath = (p: string) => path.relative(CONTENT_DIR, p);

  for (const filePath of files) {
    const relPath = getRelPath(filePath);
    const content = fs.readFileSync(filePath, 'utf8');
    const { data, content: bodyContent } = matter(content);
    const fm = data as FrontMatter;

    // Validation
    if (!fm.slug) {
      console.error(`âŒ Missing slug in front-matter: ${relPath}`);
      process.exit(1);
    }
    if (!fm.title) {
      console.error(`âŒ Missing title in front-matter: ${relPath}`);
      process.exit(1);
    }

    // Determine Category (Root Directory)
    const pathParts = relPath.split(path.sep);
    const category = pathParts[0];
    if (!ROOT_CATEGORIES.includes(category)) {
      console.warn(`âš ï¸ File ${relPath} is in unknown category "${category}". Skipping.`);
      continue;
    }

    // Check for Duplicate Post Slug
    if (posts.some(p => p.slug === fm.slug)) {
      console.error(`âŒ Duplicate post slug found: "${fm.slug}" in ${relPath}`);
      process.exit(1);
    }

    // 1. Prepare Post
    posts.push({
      slug: fm.slug,
      title: fm.title,
      excerpt: fm.excerpt || '',
      content_md: bodyContent, // No trim() as requested (preserves exact content)
      category: category,
      published_date: normalizePublishedDate(fm.published_date), // Safe Normalized Date
    });
    
    // Store mapping for node generation
    filePostMap.set(relPath, fm.slug);

    // 2. Prepare Tags
    const pathPartsLen = pathParts.length;
    const autoTags = [];
    if (pathPartsLen > 2) {
      autoTags.push(pathParts[1]); 
    }
    const rawTags = [...(fm.tags || []), ...autoTags];

    for (const t of rawTags) {
      const normSlug = slugify(t);
      if (!normSlug) continue; 
      
      // First Name Wins
      if (!tagsMap.has(normSlug)) {
        tagsMap.set(normSlug, { slug: normSlug, name: t });
      } else {
        // 4) è¡çªè­¦å‘Š
        const existing = tagsMap.get(normSlug)!;
        if (existing.name !== t) {
            console.warn(`âš ï¸ Tag Collision: Slug "${normSlug}" | Existing: "${existing.name}" | New: "${t}". Keeping existing.`);
        }
      }
    }
  }

  // 3. Build Node Tree (Virtual)
  function walkForNodes(currentDir: string, parentPath: string | null) {
      const items = fs.readdirSync(currentDir);
      
      const folders = items.filter(i => fs.statSync(path.join(currentDir, i)).isDirectory());
      const mdFiles = items.filter(i => i.endsWith('.md'));

      // Process subfolders
      for (const folder of folders) {
          const fullPath = path.join(currentDir, folder);
          const relPath = getRelPath(fullPath);
          const slug = folder; // directory name is slug
          
          // 1) Strict Root Check
          if (parentPath === null && !ROOT_CATEGORIES.includes(slug)) {
              console.log(`â„¹ï¸ Skipping non-root folder: ${slug}`);
              continue; // Ignored folder
          }

          nodes.push({
              type: 'folder',
              path: relPath,
              slug: slug,
              title: slug, // Title same as directory name
              category: relPath.split(path.sep)[0],
              parentPath: parentPath
          });
          
          walkForNodes(fullPath, relPath);
      }

      // Process files
      for (const file of mdFiles) {
          const fullPath = path.join(currentDir, file);
          const relPath = getRelPath(fullPath);
          const postSlug = filePostMap.get(relPath);
          
          if (!postSlug) continue; 
          
          const filenameNoExt = path.basename(file, '.md');

          nodes.push({
              type: 'post',
              path: relPath,
              slug: filenameNoExt, // Filename without extension
              title: posts.find(p => p.slug === postSlug)?.title || filenameNoExt,
              category: relPath.split(path.sep)[0],
              parentPath: parentPath,
              postSlug: postSlug
          });
      }
  }
  
  walkForNodes(CONTENT_DIR, null);
  
  // --- SYNC EXECUTION ---
  
  console.log('ðŸ—‘ï¸  Deleting existing data (Option B)...');
  
  // 1. Delete post_tags
  const { error: e1 } = await supabase.from('post_tags').delete().not('post_id', 'is', null);
  if (e1) console.warn('Warning deleting post_tags:', e1.message);

  // 2. Delete note_nodes
  const { error: e2 } = await supabase.from('note_nodes').delete().not('id', 'is', null);
  if (e2) {
      console.error('Failed to delete note_nodes:', e2);
      process.exit(1);
  }

  // 3. Delete tags
  const { error: e3 } = await supabase.from('tags').delete().not('id', 'is', null);
  if (e3) {
      console.error('Failed to delete tags:', e3);
      process.exit(1);
  }

  // 4. Delete posts
  const { error: e4 } = await supabase.from('posts').delete().not('id', 'is', null);
  if (e4) {
      console.error('Failed to delete posts:', e4);
      process.exit(1);
  }

  console.log('âœ… Deletion complete.');

  // --- INSERTION ---
  
  // 5. Insert Posts
  console.log(`Inserting ${posts.length} posts...`);
  if (posts.length > 0) {
      const { data: insertedPosts, error: ep } = await supabase
          .from('posts')
          .insert(posts)
          .select('id, slug'); // Need IDs for relations
      
      if (ep) {
          console.error('Failed to insert posts:', ep);
          process.exit(1);
      }
      
      // Update our posts list with IDs
      for (const p of posts) {
          const match = insertedPosts.find(ip => ip.slug === p.slug);
          if (match) p.id = match.id;
      }
  }

  // 6. Insert Tags
  const tagsList = Array.from(tagsMap.values());
  console.log(`Inserting ${tagsList.length} tags...`);
  const tagSlugToId = new Map<string, string>();
  
  if (tagsList.length > 0) {
      const { data: insertedTags, error: et } = await supabase
          .from('tags')
          .insert(tagsList)
          .select('id, slug');
          
      if (et) {
          console.error('Failed to insert tags:', et);
          process.exit(1);
      }
      
      for (const t of insertedTags) {
          tagSlugToId.set(t.slug, t.id);
      }
  }

  // 7. Insert Post_Tags
  const postTagsRows = [];
  
  for (const filePath of files) {
      const relPath = getRelPath(filePath);
      const content = fs.readFileSync(filePath, 'utf8');
      const { data } = matter(content);
      const fm = data as FrontMatter;
      
      const post = posts.find(p => p.slug === fm.slug);
      if (!post || !post.id) continue;

      const pathParts = relPath.split(path.sep);
      const autoTags = (pathParts.length > 2) ? [pathParts[1]] : [];
      const rawTags = [...(fm.tags || []), ...autoTags];
      
      const uniqueTagSlugs = new Set<string>();
      for (const t of rawTags) {
          const s = slugify(t);
          if (s) uniqueTagSlugs.add(s);
      }
      
      for (const s of uniqueTagSlugs) {
          const tagId = tagSlugToId.get(s);
          if (tagId) {
              postTagsRows.push({ post_id: post.id, tag_id: tagId });
          }
      }
  }

  console.log(`Inserting ${postTagsRows.length} post_tag relations...`);
  if (postTagsRows.length > 0) {
      const { error: ept } = await supabase.from('post_tags').insert(postTagsRows);
      if (ept) {
          console.error('Failed to insert post_tags:', ept);
          process.exit(1);
      }
  }

  // 8. Insert Note Nodes
  console.log('Inserting note_nodes...');
  
  const pathNodeIdMap = new Map<string, string>(); // relPath -> uuid

  for (const node of nodes) {
      if (node.type === 'post') {
          if (node.postSlug) {
              const p = posts.find(x => x.slug === node.postSlug);
              if (p && p.id) {
                  node.postId = p.id;
              }
          }
          // 2) Strict Post ID Check
          if (!node.postId) {
              console.error(`âŒ Critical: Note Node "${node.path}" (Slug: ${node.postSlug}) has no matching post_id in DB.`);
              process.exit(1);
          }
      }
  }

  const getDepth = (p: string) => p.split(path.sep).length;
  const maxDepth = Math.max(...nodes.map(n => getDepth(n.path)), 0);
  
  for (let d = 1; d <= maxDepth; d++) {
      const layerNodes = nodes.filter(n => getDepth(n.path) === d);
      
      layerNodes.sort((a, b) => {
          const getOrder = (slug: string) => {
              if (slug === 'projects') return 10;
              if (slug === 'certifications') return 20;
              if (slug === 'notes') return 30;
              return 999;
          };
          if (d === 1) {
             return getOrder(a.slug) - getOrder(b.slug);
          }
          return a.slug.localeCompare(b.slug);
      });
      
      const rowsToInsert = layerNodes.map(node => {
         let parentId = null;
         if (node.parentPath) {
             parentId = pathNodeIdMap.get(node.parentPath) || null;
         }
         
         let sortOrder = 0;
         if (d === 1) {
             if (node.slug === 'projects') sortOrder = 10;
             else if (node.slug === 'certifications') sortOrder = 20;
             else if (node.slug === 'notes') sortOrder = 30;
         }
         
         return {
             parent_id: parentId,
             node_type: node.type,
             slug: node.slug,
             title: node.title,
             sort_order: sortOrder, 
             post_id: node.postId || null,
             _original_path: node.path 
         };
      });
      
      // Correct Sort Orders
      const groups = new Map<string | null, typeof rowsToInsert>();
      for (const row of rowsToInsert) {
          const pid = row.parent_id;
          if (!groups.has(pid)) groups.set(pid, []);
          groups.get(pid)!.push(row);
      }
      
      for (const [pid, group] of groups) {
          group.sort((a, b) => {
             if (pid === null) {
                  const getOrder = (s: string) => {
                      if (s === 'projects') return 10;
                      if (s === 'certifications') return 20;
                      if (s === 'notes') return 30;
                      return 999;
                  };
                  return getOrder(a.slug) - getOrder(b.slug);
             }
             return a.slug.localeCompare(b.slug);
          });
          
          group.forEach((row, idx) => {
               if (pid === null) {
                  if (row.slug === 'projects') row.sort_order = 10;
                  else if (row.slug === 'certifications') row.sort_order = 20;
                  else if (row.slug === 'notes') row.sort_order = 30;
                  else row.sort_order = 100 + idx;
               } else {
                  row.sort_order = (idx + 1) * 10;
               }
          });
      }
      
      const dbRows = rowsToInsert.map(({ _original_path, ...r }) => r);
      
      if (dbRows.length > 0) {
          const { data: insertedNodes, error: en } = await supabase
              .from('note_nodes')
              .insert(dbRows)
              .select('id, slug, parent_id');
              
          if (en) {
             console.error(`Failed to insert note_nodes at depth ${d}:`, en);
             process.exit(1); 
          }
          
          for (const node of rowsToInsert) {
              const match = insertedNodes.find(n => n.slug === node.slug && n.parent_id === node.parent_id);
              if (match) {
                  pathNodeIdMap.set(node._original_path, match.id);
              }
          }
      }
  }

  console.log('âœ… Sync completed successfully.');
}

main().catch(e => {
  console.error('Unhandled Error:', e);
  process.exit(1);
});
